import { FormatDuration } from "@/_tools/display";
import { NS } from "@ns";

export async function main(ns: NS) {
	ns.disableLog("ALL");
	ns.clearLog();
	ns.tail();
	await ns.sleep(1);
	ns.resizeTail(300, 300);

	goToCasino(ns);
	startCoinFlip();

	while (ns.getMoneySources().sinceInstall.casino < 10_000_000_000) {
		ns.clearLog();
		ns.print("GETTING SEQUENCE");

		try {
			setMoneyInput(-1);

			const { tails, heads } = getHeadTailButtonRefs();

			const sequence = await getSequence(ns, tails);

			console.log("SEQ", sequence);

			await validateSequence(ns, sequence, tails);
			await validateSequence(ns, sequence, tails);

			console.log("SEQ VALID");

			setMoneyInput(10000);

			await executeSequence(ns, sequence, tails, heads);
		} catch (e) {
			console.error("COIN FLIP ERROR! REBASE!");
			console.error(e);
		}

		await ns.sleep(500);
	}
}


function money(money: number, digits: number) {
	const minus = money < 0;
	if (minus) money *= -1;
	const lookup = [
		{ value: 1,
			symbol: "" },
		{ value: 1_000,
			symbol: "k" },
		{ value: 1_000_000,
			symbol: "m" },
		{ value: 1_000_000_000,
			symbol: "b" },
		{ value: 1_000_000_000_000,
			symbol: "t" },
		{ value: 1_000_000_000_000_000,
			symbol: "q" },
		{ value: 1_000_000_000_000_000_000,
			symbol: "Q" }
	];
	const rx = /\.0+$|(\.[0-9]*[1-9])0+$/;
	const item = lookup.slice().reverse().find(function(item) {
		return money >= item.value;
	});
	return (minus ? "-" : "") + (item ? (money / item.value).toFixed(digits).replace(rx, "$1") + item.symbol : "0");
}


function progressBar(percentage: number, size: number) {
	const lit = Math.round(percentage * size);
	const unLit = size - lit;
	return `[${String("").padEnd(lit, "|")}${String("").padEnd(unLit, "-")}]`;
}


export function goToCasino(ns: NS) {
	if (ns.getPlayer().city !== "Aevum" && !ns.singularity.travelToCity("Aevum")) {
		throw new Error("Could not get to Aevum!");
	}

	if (!ns.singularity.goToLocation("Iker Molina Casino")) {
		throw new Error("Could not get to the casino!");		
	}
}

export function startCoinFlip() {
	const doc = eval("document") as Document;
	const allButtons = doc.querySelectorAll("button");
	const coinFlip = Array.from(allButtons).find(b => b.textContent?.toLowerCase() === "play coin flip");
	if (coinFlip === undefined) throw new Error("Could not find coin flip game!");
	clickButton(coinFlip);
}

export function getHeadTailButtonRefs() {
	const doc = eval("document") as Document;
	const allButtons = doc.querySelectorAll("button");
	const tails = Array.from(allButtons).find(b => b.textContent?.toLowerCase() === "tail!");
	const heads = Array.from(allButtons).find(b => b.textContent?.toLowerCase() === "head!");
	if (tails === undefined || heads === undefined) throw new Error("Could not find heads and tails!");
	return {
		tails,
		heads
	};
}

export async function getSequence(ns: NS, tails: HTMLButtonElement) {
	const sequence = new Array<string>();
	for (let i = 0; i < 1024; i++) {
		clickButton(tails);
		const result = findResult();
		if (result.textContent === null) throw new Error("Got result with no text content!");
		sequence.push(result.textContent);
		await ns.asleep(1);
	}
	return sequence;
}

export async function validateSequence(ns: NS, sequence: Array<string>, tails: HTMLButtonElement) {
	for (let i = 0; i < 1024; i++) {
		clickButton(tails);
		const result = findResult();
		if (result.textContent === null) throw new Error("Got result with no text content!");
		if (sequence[i] !== result.textContent) throw new Error(`Sequence at Pos #${i} does not match with result! ${sequence[i]} : ${result.textContent}`);
	}
}

export async function executeSequence(ns: NS, sequence: Array<string>, tails: HTMLButtonElement, heads: HTMLButtonElement) {
	let rounds = 0;
	let lastTime = Date.now();
	let lastIncome = ns.getMoneySources().sinceInstall.casino;

	while (ns.getMoneySources().sinceInstall.casino < 10_000_000_000) {
		const value = sequence[rounds++ % 1024];

		clickButton(value === "T" ? tails : heads);

		if (!hasWon()) {
			throw new Error(`Something went wrong! Lost with sequence pos #${(rounds - 1) % 1024}! Expected ${value}, Bet on ${value === "T" ? "Tails" : "Heads"}!`);
		}
		
		if (rounds % 1000 === 0) {
			const currentTime   = Date.now();
			const currentIncome = ns.getMoneySources().sinceInstall.casino;
			const incomeRate    = ((currentIncome - lastIncome) / (currentTime - lastTime)) * 1000;

			display(ns, currentIncome, incomeRate);
			await ns.asleep(1);
		}
	}
}

function display(ns: NS, currentIncome: number, incomeRate: number) {
	const left = 10_000_000_000 - currentIncome;
	const secondsRemaining = left / incomeRate;
	const completionPercent = currentIncome / 10_000_000_000;
	const bar = progressBar(completionPercent, 20);

	ns.clearLog();
	ns.print("Current Progress");
	ns.print(`${bar} ${Math.floor(completionPercent * 100)}%`);
	ns.print(`  Income: ${money(currentIncome, 2)}`);
	ns.print(`  ETA: ${FormatDuration(ns, secondsRemaining * 1000)}`);
	ns.print(`  Income Rate: ${ns.formatNumber(incomeRate)}/sec`);
}

export function setMoneyInput(money: number) {
	const doc = eval("document") as Document;
	const allInputs = doc.querySelectorAll("input");
	const numberInput = Array.from(allInputs).find(i => i.type === "number");
	if (numberInput === undefined) throw new Error("Could not find number input!");
	numberInput.value = String(money === -1 ? "" : money);
}

export function findResult() {
	const doc = eval("document") as Document;
	const allP = doc.querySelectorAll("p");
	const result = Array.from(allP).find(p => p.textContent === "H" || p.textContent === "T");
	if (result === undefined) throw new Error("Could not find result!");
	return result;
}

export function hasWon() {
	const doc = eval("document") as Document;
	const allH3 = doc.querySelectorAll("h3");
	const result = Array.from(allH3).find(h => h.textContent === " win!" || h.textContent === "lose!");
	if (result === undefined) throw new Error("Could not find the result h3!");
	return result.textContent === " win!";
}

export function clickButton(ref: HTMLElement) {
	const obj = ref[Object.keys(ref)[1] as keyof HTMLElement] as unknown as simpleObject; // no idea what type that is (maybe ReactProps somethingsomething), casting to simpleObject to please TS
	obj.onClick({ isTrusted: true } as MouseEvent);
}

interface simpleObject {
	onClick: (a: MouseEvent) => void;
}